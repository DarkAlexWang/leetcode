/*
HJ3_明明的随机数
桶排序的思想
本题也可以用set，set的构造函数及特性，set的特性是无重复且无自动排序？
************************
HJ17_坐标移动
2019年提交过，为什么没有通过呢？
************************
HJ39_判断两个IP是否属于同一个子网
************************
sacnf中，如果格式与变量类型不匹配会怎么样呢？
失效的格式后面，不会再向变量内读入信息，变量会保持原来的值
例如，
unsignde mask[4] = {255, 255, 255, 255};
scanf("%u.%u.%u.%u", &mask);
cout<<mask[0]<<" "<<mask[1]<<" "<<mask[2]<<" "<<mask[3]<<" ";

如果输入10..12.255.239, 程序运行后的输出是10 255 255 255

************************
判断ip地址，可以直接用网络库
#include <arpa/inet.h>
int inet_pton(int family, const char *strptr, void *addrptr);
            返回：若成功则为1,若输入不是有效的表达格式则为0,若出错则为-1
HJ18 "识别有效的IP..." TOP1解题中有使用

reference：(还未看)
https://blog.csdn.net/zyy617532750/article/details/58595700/

************************
如何判断一个掩码地址是不是满足前面连续是1，然后全是0？
将掩码地址转换为32位无符号整型，假设这个数为b。如果此时b为0，则为非法掩码
将b按位取反后+1。如果此时b为1，则b原来是二进制全1，非法掩码
如果b和b-1做按位与运算后为0，则说明是合法掩码，否则为非法掩码
原理是，只筛选出最后一个1和0的交界，然后过滤
b的类型用unsigned int(32bit)，不要用unsigned long(64bit)、std::size_t(64bit)、

unsigned 也是32bit
unsigned char 8bit
unsigned short 16bit


**************************
字符串转整形的方法：
①stringstream
②int = std::stoi(string)
 unsigned long  = std::stoul(string)
**************************
HJ28_素数伴侣
//20201009 16:03-16:42(看讨论，图匈牙利算法，有点儿难)
**************************
HJ41 称砝码
set拥有与list相同的某些性质：当客户端对其进行元素新增或删除操作时，操作之前的所有迭代器，在操作完成后，
依然有效，当然，被删除元素的迭代器必然是个例外。

**************************
HJ42 学英语
 输出格式自验方法（是否多输出了一个结尾的空格）：将空格改为“|”输出

**************************
HJ44
dfs模板
(是否需要选择一个起点)
dfs(int step)
{
    判断边界条件是否抵达
    {
        (判断是否满足要求)
        相应操作(设置成功标记flag)
    }

    对于当前的每一种满足要求的可能
    {
        选择一种可能 solution
        dfs(step+1)
        判断是否成功(成功标记flag)
        {
            成功则return
            不成功则清除solution的印记
        }
    }

}

*******************************
HJ47出现“段错误”，但是看打印，死在了输入输出，可是输入输出怎么也没错。这时，把功能函数注释一下，可能就好了。说明是功能函数出了问题。


  node* pre = NULL, *cur = first;

*********************************
HJ60 查找组成一个偶数最接近的两个素数
如何判断一个数m是不是素数(Prime)？只需要判断m能不能被2-sqrt(m)之间的整数整除即可
reference：http://c.biancheng.net/view/498.html
*********************************
HJ51
new数组用 new array[num];
delete数组用 delete[] array;
********************************************
HJ54  表达式求值
char转string，不要用to_string(参数)，因为这个调用的是to_string(int)，会把char当做一个整数，翻译做数字
              要用string(1,char)，或者string={char}，都是调用string的构造函数，直接生成一个string

使用stringstream>>int>>string;//这个语句中，如果向int输入后，stringstream中不存在其他东西后，string将仍然保持原来的值，不会被清空。
              所以，循环输入的时候，需要清空int、string，否则无法知道int或者string中是否是新输入的数据
********************************************
HJ55  挑7
注意，是to_string(参数)，而不是tostring(参数)
********************************************
HJ56    iNOC产品部--完全数计算
本题要注意的一个点，就是算法的复杂度，不要超时
但是奇怪的是，使用查表的方式，竟然比“不查表的”方式还要慢
通过查看完美数的分部情况“6, 28, 496, 8128”推测，在排除10000-500000这段，花了过长的时间
有些是否，添加一句排除冗余情况的代码，可以提高算法速度30%
另外一种思路，欧拉公式：如果i是质数，2^i-1也是质数，那么（2^i-1）*2^(i-1)就是完全数。
***********************************************
HJ58 堆排序
make_heap(begin,end, cmp);
pop_heap(begin,end, cmp);//将最大值移动到heap末尾, cmp应与make_heap中的额cmp相同
push_heap(begin,end,cmp)//将末尾的元素纳入到heap中, cmp应与make_heap中的额cmp相同
sort_heap(heap, heap+out_num,cmp);//按照heap的cmp对heap排序，排序后，会失去heap的属性; cmp应与make_heap中的额cmp相同
**********************************************
HJ67 24点运算
    next_permutation是从sort结果后的全排列
    next_permutation(first, last , comp)，返回为true，表示成功获得下一个全排列，返回false，表示全排列已经全部遍历完毕
    next_permutation头文件是numeric
***********************************************
HJ71 字符串通配符
头文件是#include<sstream>，而不是<stringstream>
***********************************************
HJ79 计算字符串相似度
内建类型转字符串是to_string，而不是tostring
http://blog.csdn.net/zzran/article/details/8274735  需要看！！！
  这篇博客有详细的解释
***********************************************
HJ82_将真分数分解为埃及分数

斐波那契提出的一种算法
∵ a/b是一个真分数
∴ b = a*q+r  0<r<a
  b/a = q+r/a
  b/a < (q+1)
  a/b > 1/(q+1)
  则a/b可以分解为1/(1+q) 和 a/b-1/(1+q) = (a-r)/[(q+1)b]=(a-b%a)/[(b/a+1)*b]

  辗转相除法：如果c是a和b的最大公约数，则c也是b和a%b的最大公约数。
    int getGCD(int a, int b)
    {
        int temp = 0;
        while(0!=a%b)
        {
            temp= b;
            b = a%b;
            a = temp;
        }
        return b;
    }
***********************************************
HJ88 扑克牌大小
//第一次段错误，原因是，向量定义后，直接访问元素，此时向量中还没有元素呢。
    vector<vector<int>> cards_array(2);//如果写成vector<vector<int>> cards_array(2)，会出现段错误
    cut(card1, cards_array[0]);
    cut(card2, cards_array[1]);
//第二次只有50%通过的原因是，炸弹是4个，写成了3个
//第三次只有90%通过的原因是，Q和K和A和2的大小关系不对

//本题的关键在于，剪切字符串，字符串比较（2比9大，2比10大等等），以及搞清楚炸弹是几个
***********************************************
HJ91_201301 JAVA题目2-3级
本题解法：①dfs ②动态规划  ③排列组合算法
***********************************************
HJ91_201301 JAVA题目0-1级
std::accumulate(begin(), end(), init_value, binary_op)//binary_op可选，
binary_op表示以init_value为左操作数，迭代器范围元素为右操作数，进行相关运算；默认情况下，是累加
HJ94_计票统计
这道题不要用map<string,int>来配对名字和票数，因为map会打乱输入顺序
map会默认排序，这个解法，对于输出时候的顺序，不一定会和输入的名字顺序一致吧
 */
